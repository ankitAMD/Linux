
# ğŸŒ Kubernetes Basics â€“ Pods, Deployments, Services & Namespaces

---

## ğŸ³ From Docker to Kubernetes

* **Docker Container(s)** â†’ wrapped inside a **Pod**
* **Pod** â†’ managed by a **Deployment**
* **Deployment** â†’ exposed to outside world via a **Service**

ğŸ‘‰ For **autoscaling & autohealing** â†’ we use **Deployments**
ğŸ‘‰ For **external access** â†’ we use **Services**

Example:

```
[NGINX Container] â†’ [Pod] â†’ [Deployment] â†’ [Service] â†’ ğŸŒ User Access
```

Similarly for **MySQL Container**, only configuration changes differ.

---

## âš¡ Why Namespaces?

When multiple apps (like **Nginx**, **MySQL**) run on the **same cluster**, confusion arises.
To manage them properly â†’ **Namespaces** are used.

Think of **Namespaces** like **WhatsApp Groups**:

* Family group
* Friends group
* Work group

ğŸ“Œ Same way, Kubernetes uses **Namespaces** to isolate resources.

---

## ğŸ“¦ Namespace Concept

**Namespace = Group of resources (Pods, Deployments, Services, etc.) isolated from other groups.**

âœ… Better management
âœ… No resource conflicts
âœ… Logical separation

---

## ğŸ“ Default Namespaces in Kubernetes

```bash
kubectl get namespace
```

Output:

* **default** â†’ If you donâ€™t specify a namespace, workloads go here.
* **kube-node-lease** â†’ Stores cluster node lease info.
* **kube-public** â†’ Public resources (accessible to all).
* **kube-system** â†’ System-level pods (DNS, kube-proxy, etc.).
* **local-path-storage** â†’ Default storage for local clusters.

---

## ğŸ› ï¸ Namespace Commands

```bash
# Check all namespaces
kubectl get ns

# Create new namespace
kubectl create ns nginx

# Run pod inside a namespace
kubectl run nginx --image nginx -n nginx

# List pods inside namespace
kubectl get pods -n nginx

# Delete pod inside namespace
kubectl delete pod nginx -n nginx

# Delete namespace
kubectl delete ns nginx
```

---

## ğŸ“‚ Using Manifest Files

For better practice, create YAML manifests:

* `namespace.yml` â†’ Creates namespace
* `pod.yml` â†’ Defines Nginx pod
* `deployment.yml` â†’ Defines scalable deployment

Commands:

```bash
kubectl apply -f namespace.yml
kubectl apply -f pod.yml
kubectl apply -f deployment.yml

kubectl get pods -n nginx
kubectl exec -it pod/nginx-pod -n nginx -- bash
kubectl describe pod/nginx-pod -n nginx
```

---

## ğŸ”‘ Key Takeaway

ğŸ‘‰ **Creating a Pod is not a speciality.**
ğŸ‘‰ **Making a Pod scalable & self-healing requires a Deployment.**

ğŸ“Œ **Rule of Thumb:**

* **One Pod = One main container (best practice)**
* **Pods scale horizontally (replicas)**, not by adding containers inside one pod.

---
